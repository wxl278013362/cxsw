/****************************************************************************
  Copyright(C)    2020,      Creality Co.Ltd.
  File name :     CrLcm12864Show.c
  Author :        chenli
  Version:        1.0
  Description:    12864 显示Posix接口实现
  Other:
  Mode History:
          <author>        <time>      <version>   <desc>
          chenli          2020-9-30    V1.0.0.1
****************************************************************************/
#include "stm32f4xx_hal.h"
#include "CrLcm12864Show.h"
#include "CrLcdSpi.h"
#include "CrGpio/CrGpio.h"
#include "rtthread.h"
#include "rthw.h"
#include "Common/Include/CrSleep.h"

#define     NAME_MAX_LENGTH                 12
#define     USING_ASCII_CHARACTER_SET       0
#define     USING_UTF8_CHARACTER_SET        1

struct LcdU8g_t
{
    u8g2_t  U8g;
    S8      Name[NAME_MAX_LENGTH];
    S32     X;
    S32     Y;
    S32     Width;
    S32     Height;
    U32     CtrlFlag;        //控制标志：写字符还是画图
    U32     CharacterSet;    //字符集 ：0是ascii码的字符串集， 1 是UTF8字符集
};

struct LcdU8g_t LcdU8g;
static S32      SpiFd = -1;     //表示没有Spi

/*Make sure to execute so many idle instructions*/
//#define WAIT_LCD_RESPONSE() {\
//    __NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();\
//    __NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();\
//    __NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();\
//    __NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();\
//    __NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();\
//    __NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();\
//    __NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();\
//    __NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();\
//    __NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();\
//    __NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();\
//    __NOP();__NOP();__NOP();__NOP();__NOP();__NOP();__NOP();\
//};

/*
//获取当前字符集
static int GetCurrentFontWidth()
{
    return LcdU8g.U8g.font_info.max_char_width;	
}*/

/*提供U8G2使用的延时回调*/
U8 U8G2GpioAndDelay(u8x8_t *u8x8, U8 Msg, U8 ArgInt, VOID *ArgPtr)
{
    switch( Msg )
    {
        case U8X8_MSG_GPIO_AND_DELAY_INIT:
            ArgInt = 10;
        case U8X8_MSG_DELAY_MILLI:
        {
            rt_thread_delay(ArgInt);
            break;
        }
        case U8X8_MSG_DELAY_100NANO:
        {
            __NOP();
            break;
        }
        case U8X8_MSG_DELAY_10MICRO:
        {    
            CrU_Sleep(10);
            break;
        }
    }

    return 1;
}

/*提供U8G2使用的SPI发送回调*/
U8 U8x8Byte4WireHwSpi(u8x8_t *U8x8, U8 Msg, U8 ArgInt, VOID *ArgPtr)
{
    if ( SpiFd < 0 )
        return 0;

    U8 Byte;
    U8 *Data;

    if ( Msg ==  U8X8_MSG_BYTE_SEND )
    {
        Data = (U8 *)ArgPtr;
        while( ArgInt-- )
        {
            Byte = *Data;
            Data++;

            CrLcdSpiWrite(SpiFd, (S8 *)&Byte, 1);
            CrU_Sleep(20);
        }
    }

    return 1;   /*SUCCESSFULLY*/
}

/*
    参数    Name: 设备名称
    参数    Flag: 暂无
    参数    Mode: 暂无

    返回值      : 返回0调用成功
    描述        : 初始化U8G2
*/
S32 CrLcm12864Open(S8 *Name, S32 Flag, S32 Mode)   //打开12864屏，用flag可以设置字符集
{
    if ( Name == NULL )
        return -1;

    u8g2_Setup_st7920_s_128x64_f(&LcdU8g.U8g, U8G2_R0, U8x8Byte4WireHwSpi, U8G2GpioAndDelay);

    return 0;
}

/*
    参数      Fd: CrLcdSpiOpen成功调用后返回的描述符

    返回值      : 无
    描述        : 清除屏幕显示，反初始化SPI
*/
VOID CrLcm12864Close(S32 Fd)  //关闭12864屏
{
    if ( SpiFd < 0  || Fd < 0 )
        return ;

    u8g2_ClearBuffer(&LcdU8g.U8g);         //清除显示缓冲区
    u8g2_ClearDisplay(&LcdU8g.U8g);        //清除屏幕显示, 显示的内容就不存在了
    CrLcdSpiClose(SpiFd);

    return ;
}


/*
    参数    Name: CrLcdSpiOpen成功调用后返回的描述符
    参数    Buff: 要写入的数据
    参数    Len : 暂无
    
    返回值      : 写图片时成功时返回0，写字符串成功返回长度
    描述        :
*/
S32 CrLcm12864Write(S32 Fd, S8 *Buff, S32 Len)  //写数据
{
    S32 Ret = -1;
    //rt_kprintf("%s fd = %d, Buff = %p, Len = %d\n", __FUNCTION__, Fd, Buff, Len);
    if ( Fd < 0 )
        return Ret;

   // rt_kprintf("u8g ctrlflag = %d, x = %d, y = %d, width = %d, height = %d\n"
   //         , LcdU8g.CtrlFlag, LcdU8g.X, LcdU8g.Y, LcdU8g.Width, LcdU8g.Height);
    switch ( LcdU8g.CtrlFlag )
    {
        case LCD_WRITE_MAP:
        {
            u8g2_DrawXBMP(&LcdU8g.U8g, LcdU8g.X, LcdU8g.Y, LcdU8g.Width, LcdU8g.Height, (const uint8_t *)Buff);
            Ret = 0;
            break;
        }
        case LCD_WRITE_STRING:
        {
            if ( LcdU8g.CharacterSet == USING_ASCII_CHARACTER_SET )
            {
                Ret = u8g2_DrawStr(&LcdU8g.U8g, LcdU8g.X, LcdU8g.Y, Buff);
            }
            else
            {
                Ret = u8g2_DrawUTF8(&LcdU8g.U8g, LcdU8g.X, LcdU8g.Y, Buff);
            }
            break;
        }
        default:
        {
            return Ret;
        }
    }

    return Ret;
}

/*
    参数    Name: CrLcdSpiOpen成功调用后返回的描述符
    参数    Buff: 保存读出数据的缓冲区
    参数    Len : 暂无
    
    返回值      : SPI的状态
                HAL_OK       = 0x00U,
                HAL_ERROR    = 0x01U,
                HAL_BUSY     = 0x02U,
                HAL_TIMEOUT  = 0x03U
    描述        :
*/
S32 CrLcm12864Read(S32 Fd, S8 *Buff, S32 Len)      // 读数据
{
    if ( SpiFd < 0 )
        return -1;

    return CrLcdSpiRead(SpiFd, Buff, Len);
}

/*
    参数          Fd: CrLcdSpiOpen成功调用后返回的描述符
    参数         Cmd: 参考CrLcm12864Show.h中宏定义
    参数  CtrlParam : 暂无
    
    返回值      : 返回0调用成功
    描述        :
*/
S32 CrLcm12864Ioctl(S32 Fd, U32 Cmd, struct LcdCtrlParam_t *CtrlParam)    //控制
{
    S32 Ret = -1;
    //rt_kprintf("********************cmd = %0x, Ret = %0x, Fd = %d\n", Cmd, LCD_GET_FONT_WIGTH_OFCURRENT, Fd);
    if ( Fd < 0 )
        return Ret;

    switch ( Cmd )
    {
        case LCD_USING_ASCII_CHARATER_SET: //设置英文字库
        {
            LcdU8g.CharacterSet = USING_ASCII_CHARACTER_SET;
            //printf("Set English\n");
            u8g2_SetFont(&LcdU8g.U8g, FontAscii);
            break;
        }
        case LCD_USING_UTF8_CHARATER_SET: //设置中文字库
        {
            LcdU8g.CharacterSet = USING_UTF8_CHARACTER_SET;
            u8g2_SetFont(&LcdU8g.U8g, FontChinese);
            break; 
        }
        case LCD_WRITE_HOR_LINE: //画横线
        {
            if ( CtrlParam != NULL )
            {
                LcdU8g.X = CtrlParam->X;
                LcdU8g.Y = CtrlParam->Y;
                LcdU8g.Width = CtrlParam->Width;
                u8g2_DrawHLine(&LcdU8g.U8g, LcdU8g.X, LcdU8g.Y, LcdU8g.Width);
            }

            break; 
        }
        case LCD_WRITE_VER_LINE: //画竖线
        {
            if ( CtrlParam != NULL )
            {
                LcdU8g.X = CtrlParam->X;
                LcdU8g.Y = CtrlParam->Y;
                LcdU8g.Height = CtrlParam->Height;
                u8g2_DrawVLine(&LcdU8g.U8g, LcdU8g.X, LcdU8g.Y, LcdU8g.Height);
            }

            break; 
        }
        case LCD_WRITE_RECTANGLE: //画矩形
        {
            if ( CtrlParam != NULL )
            {
                LcdU8g.X = CtrlParam->X;
                LcdU8g.Y = CtrlParam->Y;
                LcdU8g.Width = CtrlParam->Width;
                LcdU8g.Height = CtrlParam->Height;
                u8g2_DrawFrame(&LcdU8g.U8g, LcdU8g.X, LcdU8g.Y, LcdU8g.Width, LcdU8g.Height);
            }

            break; 
        }  
        case LCD_WRITE_MAP: //显示图片
        {
            if ( CtrlParam != NULL )
            {
//                rt_kprintf("-------------- ioctl write map X = %d, Y = %d, Width = %d, Height = %d\n",
//                        CtrlParam->X, CtrlParam->Y, CtrlParam->Width, CtrlParam->Height);
                LcdU8g.X = CtrlParam->X;
                LcdU8g.Y = CtrlParam->Y;
                LcdU8g.Width = CtrlParam->Width;
                LcdU8g.Height = CtrlParam->Height;
                LcdU8g.CtrlFlag = LCD_WRITE_MAP;
            }

            break;
        }     
        case LCD_WRITE_STRING: //写字符串
        {
            if ( CtrlParam != NULL )
            {
                LcdU8g.X = CtrlParam->X;
                LcdU8g.Y = CtrlParam->Y;
                LcdU8g.CtrlFlag = LCD_WRITE_STRING;
            }

            break; 
        }   

        case LCD_CLEAN: //清屏
        {
            u8g2_ClearBuffer(&LcdU8g.U8g);         //清除显示缓冲区
       //     u8g2_ClearDisplay(&LcdU8g.U8g);      //清除屏幕显示
            break; 
        }    

        case LCD_FLUSH: //刷屏
        {
            u8g2_SendBuffer(&LcdU8g.U8g);

            break; 
        }
        case LCD_SET_SPI: 
        {
//            rt_kprintf("param is %p\n", CtrlParam);
            if ( CtrlParam )
            {
                SpiFd = *((S32 *)CtrlParam);
//                rt_kprintf("param is spi fd = %d\n", SpiFd);
                u8g2_InitDisplay(&LcdU8g.U8g);
                u8g2_SetPowerSave(&LcdU8g.U8g, 0);
            }
            break;
        }
        case LCD_GET_FONT_WIGTH_OFCURRENT:
        {
            Ret = LcdU8g.U8g.font_info.max_char_width;
            break;
        }
        default:

            return Ret;
        }


    return Ret;
}

#ifdef CRLCM12864_TEST

static const unsigned char bmp1[] U8X8_PROGMEM = {
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0x07,0x60,0x00,0xF8,0x1F,0x80,0xFF,0xFF,0xC7,0xFF,0x11,0x00,0xE0,0x7F,0xFC,
0xFF,0x01,0x60,0x00,0xF0,0x07,0x80,0xFF,0xFC,0xC7,0xFF,0x11,0x00,0xE0,0x3F,0xFE,
0x7F,0x00,0x60,0x00,0xE0,0x03,0x80,0x7F,0xFC,0xC7,0xFF,0x11,0x00,0xC0,0x1F,0xFE,
0x7F,0xF8,0x7F,0xFC,0xE7,0xE1,0xFF,0x7F,0xF8,0xC7,0xFF,0xF1,0xE7,0x8F,0x0F,0xFF,
0x3F,0xFE,0x7F,0xFC,0xC7,0xF8,0xFF,0x3F,0xF8,0xC7,0xFF,0xF1,0xE7,0x1F,0x87,0xFF,
0x3F,0xFF,0x7F,0xFC,0xC7,0xF8,0xFF,0x3F,0xF0,0xC7,0xFF,0xF1,0xE7,0x3F,0xC6,0xFF,
0x1F,0xFF,0x7F,0x04,0xE0,0xF8,0xFF,0x1F,0xF1,0xC7,0xFF,0xF1,0xE7,0x3F,0xE0,0xFF,
0x1F,0xFF,0x7F,0x04,0xE0,0x00,0x80,0x1F,0xE3,0xC7,0xFF,0xF1,0xE7,0x7F,0xF0,0xFF,
0x1F,0xFF,0x7F,0x0C,0xF8,0x00,0x80,0x8F,0xC7,0xC7,0xFF,0xF1,0xE7,0xFF,0xF0,0xFF,
0x1F,0xFF,0x7F,0x3C,0xFE,0xF8,0xFF,0xC7,0xC7,0xC7,0xFF,0xF1,0xE7,0xFF,0xF8,0xFF,
0x3F,0xFE,0x7F,0x7C,0xFC,0xF8,0xFF,0xC7,0x8F,0xC7,0xFF,0xF1,0xE7,0xFF,0xF9,0xFF,
0x3F,0xF8,0x7F,0xFC,0xF8,0xE1,0xFF,0xE3,0x8F,0xC7,0xFF,0xF1,0xE7,0xFF,0xF9,0xFF,
0x7F,0x00,0x60,0xFC,0xF1,0x01,0x80,0x63,0x00,0x07,0x80,0xF1,0xE7,0xFF,0xF9,0xFF,
0xFF,0x00,0x60,0xFC,0xE3,0x07,0x80,0x71,0x00,0x06,0x80,0xF1,0xE7,0xFF,0xF9,0xFF,
0xFF,0x03,0x60,0xFC,0xC7,0x1F,0x80,0x30,0x00,0x06,0x80,0xF1,0xE7,0xFF,0xF9,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,/*"CREALITY"*/
};

const unsigned char bmp2[] U8X8_PROGMEM = {
0xFE,0xFD,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFD,0xFE,0xFD,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFC,0xFC,0x78,0xFC,0x30,0xFC,/*"挤出头" 10 * 12*/
 };

const unsigned char bmp3[] U8X8_PROGMEM = {
0xFF,0xFC,0xFF,0xFD,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x01,0xFE,0x01,0xFE,0xFF,0xFF,			/*"SD卡" 10 * 11 */
 };

const unsigned char bmp4[] U8X8_PROGMEM = {
0x08,0x82,0x00,0x10,0x04,0x01,0x10,0x04,0x01,0x08,0x82,0x00,0x04,0x41,0x00,0x82,
0x20,0x00,0x82,0x20,0x00,0x04,0x41,0x00,0x08,0x82,0x00,0x00,0x00,0x00,0xFF,0xFF,
0x03,0xFF,0xFF,0x03,					/*"热床" 18 * 12 */
 };

const unsigned char bmp5[] U8X8_PROGMEM = {
0xFF,0xFF,0x03,0x07,0x80,0x03,0xC3,0x0F,0x03,0xC1,0x0F,0x02,0x81,0x07,0x02,0x01,
0x03,0x02,0x0D,0xC0,0x02,0x1D,0xE0,0x02,0x3D,0xF0,0x02,0x3D,0xF0,0x02,0x1D,0xE0,
0x02,0x0D,0xC0,0x02,0x01,0x03,0x02,0x81,0x07,0x02,0xC1,0x0F,0x02,0xC3,0x0F,0x03,
0x07,0x80,0x03,0xFF,0xFF,0x03,			/*"风扇" 18 * 18 */
 };

const unsigned char bmp6[] U8X8_PROGMEM = {
0x07,0x01,0x03,0x0D,0x15,0x14,0x0C,0x14,0x14,/*"FR",0*/
};

static VOID LcdShow(S32 Fds)
{   
    struct LcdCtrlParam_t Lcd = {0};

    CrLcm12864Ioctl(Fds, LCD_CLEAN, NULL);
    CrLcm12864Ioctl(Fds, LCD_USING_ASCII_CHARATER_SET, NULL);

    Lcd.X = 0;
    Lcd.Y = 16;
    CrLcm12864Ioctl(Fds, LCD_WRITE_STRING, &Lcd);
    CrLcm12864Write(Fds, "C-Spark", 0);

    Lcd.X = 45;
    Lcd.Y = 7;
    CrLcm12864Ioctl(Fds, LCD_WRITE_STRING, &Lcd);
    CrLcm12864Write(Fds, "0°", 0);

    Lcd.X = 42;
    Lcd.Y = 28;
    CrLcm12864Ioctl(Fds, LCD_WRITE_STRING, &Lcd);
    CrLcm12864Write(Fds, "34°", 0);

    Lcd.X = 77;
    Lcd.Y = 7;
    CrLcm12864Ioctl(Fds, LCD_WRITE_STRING, &Lcd);
    CrLcm12864Write(Fds, "100°", 0);

    Lcd.X = 76;
    Lcd.Y = 28;         
    CrLcm12864Ioctl(Fds, LCD_WRITE_STRING, &Lcd);
    CrLcm12864Write(Fds, "220°", 0);

    Lcd.X = 13;
    Lcd.Y = 50;         
    CrLcm12864Ioctl(Fds, LCD_WRITE_STRING, &Lcd);
    CrLcm12864Write(Fds, "100%", 0);

    Lcd.X = 59;
    Lcd.Y = 48;         
    CrLcm12864Ioctl(Fds, LCD_WRITE_STRING, &Lcd);
//	CrLcm12864Write(Fds, "00:00", 0);

    Lcd.X = 105;
    Lcd.Y = 51;         
    CrLcm12864Ioctl(Fds, LCD_WRITE_STRING, &Lcd);
//	CrLcm12864Write(Fds, "0%", 0);

    CrLcm12864Ioctl(Fds, LCD_USING_UTF8_CHARATER_SET, NULL);

    Lcd.X = 0;
    Lcd.Y = 63;         
    CrLcm12864Ioctl(Fds, LCD_WRITE_STRING, &Lcd);
    CrLcm12864Write(Fds, "准备就绪", 0);

    Lcd.X = 43;
    Lcd.Y = 8;
    Lcd.Width = 10;
    Lcd.Height = 12;
    CrLcm12864Ioctl(Fds, LCD_WRITE_MAP, &Lcd);
    CrLcm12864Write(Fds, (S8 *)bmp2, 0);

    Lcd.X = 40;
    Lcd.Y = 41;
    Lcd.Width = 10;
    Lcd.Height = 11;
    CrLcm12864Ioctl(Fds, LCD_WRITE_MAP, &Lcd);
    CrLcm12864Write(Fds, (S8 *)bmp3, 0);

    Lcd.X = 73;
    Lcd.Y = 8;
    Lcd.Width = 18;
    Lcd.Height = 12;
    CrLcm12864Ioctl(Fds, LCD_WRITE_MAP, &Lcd);
    CrLcm12864Write(Fds, (S8 *)bmp4, 0);

    Lcd.X = 105;
    Lcd.Y = 0;
    Lcd.Width = 18;
    Lcd.Height = 18;
    CrLcm12864Ioctl(Fds, LCD_WRITE_MAP, &Lcd);
    CrLcm12864Write(Fds, (S8 *)bmp5, 0);

    Lcd.X = 3;
    Lcd.Y = 42;
    Lcd.Width = 5;
    Lcd.Height = 9;
    CrLcm12864Ioctl(Fds, LCD_WRITE_MAP, &Lcd);
    CrLcm12864Write(Fds, (S8 *)bmp6, 0);

    Lcd.X = 0;
    Lcd.Y = 29;
    Lcd.Width = 128;
    Lcd.Height = 11;
    CrLcm12864Ioctl(Fds, LCD_WRITE_RECTANGLE, &Lcd);

    Lcd.X = 52;
    Lcd.Y = 49;
    Lcd.Width = 50;
    Lcd.Height = 3;
    CrLcm12864Ioctl(Fds, LCD_WRITE_RECTANGLE, &Lcd);
    CrLcm12864Ioctl(Fds, LCD_FLUSH, NULL);


    return ;
}

static S32 LcdSpiInit(void)
{
    S32 SpiFd = CrLcdSpiOpen(SPI2_NAME, 0, 0);
    if ( SpiFd < 0 )
    {
        printf("Lcd Spi OpenFail\n");
        return SpiFd;
    }

    CrLcdSpiIoctl(SpiFd, 0, NULL);  //初始化SPI

    return SpiFd;
}

static S32 Lcd12864Init()
{
    S32 LcdFd = CrLcm12864Open("Lcd12864", 0 , 0);
    if (LcdFd < 0)
    {
        printf("Lcd OpenFail\n");
        return LcdFd;
    }


    S32 Fd = LcdSpiInit();
     if (Fd < 0)
    {
        printf("Lcd Spi OpenFail\n");
        return Fd;
    }

    CrLcm12864Ioctl(Fd, LCD_SET_SPI, NULL);

    return Fd;
}

static VOID LcdShowInterFace(S32 LcdFd)
{
    struct LcdCtrlParam_t Lcd = {0};
    Lcd.X = 0;
    Lcd.Y = 0;
    Lcd.Width = 128;
    Lcd.Height = 64;

    CrLcm12864Ioctl(LcdFd, LCD_WRITE_MAP, &Lcd);
    CrLcm12864Write(LcdFd, (S8 *)bmp1, 0);
    CrLcm12864Ioctl(LcdFd, LCD_FLUSH, NULL);
    
    HAL_Delay(1000);

    return ;
}


static VOID ShowPercentage(S32 LcdFd, struct LcdCtrlParam_t *Lcd)
{
    S8 Buf[10] = {0};
    static S32 Percentage = 0;
    static S32 a = 100;
    static S32 b = 50;

    CrLcm12864Ioctl(LcdFd, LCD_USING_ASCII_CHARATER_SET, NULL);

    Lcd->X = 52;
    Lcd->Y = 50;
    Lcd->Width++;
    CrLcm12864Ioctl(LcdFd, LCD_WRITE_HOR_LINE, Lcd);

    Lcd->X = 105;
    Lcd->Y = 51;         
    CrLcm12864Ioctl(LcdFd, LCD_WRITE_STRING, Lcd);
    sprintf(Buf, "%d%s", Percentage += 2, "%");
    CrLcm12864Write(LcdFd, Buf, 0);

    Lcd->X = 59;
    Lcd->Y = 48;         
    CrLcm12864Ioctl(LcdFd, LCD_WRITE_STRING, Lcd);
    sprintf(Buf, "%d:%d", a -= 2, b -= 1);
    CrLcm12864Write(LcdFd, Buf, 0);

    CrLcm12864Ioctl(LcdFd, LCD_FLUSH, NULL);
    HAL_Delay(500);
    if ( Lcd->Width > 49 ){
        Percentage = 0;
        Lcd->Width = 0;
        a = 100;
        b = 50;
    }

    return ;
}

/*将SPI2的片选信号线拉高*/
static VOID SetSpi2Cs(VOID)
{
    struct PinInitParam_t CsPin = {0};
    struct PinParam_t CsPinState = {GPIO_PIN_RESET};

    CsPin.Mode = GPIO_MODE_OUTPUT_PP;
    CsPin.Pull = GPIO_NOPULL;
    CsPin.Speed = GPIO_SPEED_FREQ_HIGH;

    S32 CsFd = CrGpioOpen("PB12", 0, 0);           //SPI2 CS

    CrGpioIoctl(CsFd, GPIO_INIT, (VOID *)&CsPin);

    CsPinState.PinState = GPIO_PIN_SET;
    
    CrGpioWrite(CsFd, (S8 *)&CsPinState, 0);

    return ;
}

S32 CrLcm12864TestMain(VOID)
{
    SetSpi2Cs();

    S32 LcdFd = Lcd12864Init();

    LcdShowInterFace(LcdFd);

    struct LcdCtrlParam_t Lcd = {0};
    while (1)
    { 
        CrLcm12864Ioctl(LcdFd, LCD_CLEAN, NULL);
        LcdShow(LcdFd);
        ShowPercentage(LcdFd, &Lcd);
    }
}

#endif /*CRLCM12864_TEST*/
